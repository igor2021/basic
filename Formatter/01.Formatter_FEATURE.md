Особенности форматирования
====================

# Методы класса yii\base\Formatter

* **format($value, $format)** 
  * Преобразует данные **$value** в формат **$format**.

В стандартном форматировщике определены следующие форматы:

* **raw** 
  * Никакой обработки не будет применено.

* **text** 
  * Значение будет обработано методом **Html::encode()**, и в результате все HTML-теги станут обычным видимым текстом.

* **ntext** 
  * То же самое, что и **text**, но результат будет дополнительно обработан методом **nl2br()**, встроенной в PHP-функцией, которая заменять переносы строк на HTML-элементы **br**.

* **paragraphs** 
  * То же самое, что **text**, но блоки текста, текста, разделённые двумя или более пустыми строками подряд, будут обёрнуты HTML-элементом **p**.

* **html** 
  * Принимает дополнительный параметр **$config**. Значение будет обработано вызовом **HtmlPurifier::process($value, $config)**.

* **email** 
  * Значение будет обработано вызовом **Html::mailto(Html::encode($value), $value)**, таким образом, вы получите HTML-код ссылки **mailto:** с самим адресом электронной почты в качестве видимого текста.

* **image** 
  * Значение будет использовано в качестве атрибута **src** элемента **img**, HTML-код которого будет возвращён. Этот формат полезен для превращения ссылок на изображения в настоящие  отрисованные изображения на конечной HTML-странице.

* **url** 
  * Переданное значение будет исрользовано как атрибут **href** для объявления элемента **a**, HTML-код которого будет возвращён. Этот формат полезен для превращения URL в ссылки.

* **boolean** 
  * Если переданное значение в конечном счёте равно **false**, этот формат вернёт строку **No**, локализованную согласно настройкам приложения. Иначе вернёт локализованную строку **Yes**. Вы можете изменить свойство **booleanFormat** класса **Formatter** на ваше собственное определение [«No», «Yes»].

* **date** 
  * Конвертирует данное значение согласно формату, переданному вторым аргументом. Если формат явно не задан, будет использовано свойство **dateFormat** класса **Formatter**. Этот метод принимает строки, которые понимает **strtotime()**, целочисленные метки времени Unix и экземпляры **DateTime**.

* **time** 
  * То же самое, что **date**, но по умолчанию будет использовано свойство **timeFormat** класса **Formatter**.

* **datetime** 
  * То же самое, что **date**, но по умолчанию будет использовано свойство **datetimeFormat** класса **Formatter**.

* **timestamp** 
  * То же самое, что **date**, но всегда форматирует значение в виде метки времени Unix (целого числа, предоставляющее количество секунд с 1 января 1970 г.).

* **relativeTime** 
  * Переданное значение расценивается как определение даты/времени, и дополнительный аргумент также расценивается как определение даты/времени, с текущими датой/временем в качестве значения по умолчанию. Возвращает текстовое представление интервала времени между этими определениями. В качестве обоих аргументов можно передавать метки времени Unix, строки, распознаваемые функцией **strtotime()**, и экземпляры **DateTime**. Дополнительно вы можете в качестве первого и единственного аргумента передать экземпляр **DateInterval** или строку, не распознаваемую конструктором **DateTime**, но распознаваемую конструктором **DateInterval**. Посмотрите на определение метода **\yii\i18n\Formatter::asRelativeTime()**, чтобы увидеть, какие именно локализованные строки будет использовать этот формат.


* **integer** 
  * Возвращает целочисленное представление данного значения. Обратите внимание, что этот формат работает не так, как простое преобразование типа в тип **int**, Проверьте определение метода **\yii\i18n\Formatter::asInteger**, чтобы точно понять, как он осуществляет преобразование.

* **double** 
  * Возвращает строковое представление данного значения в виде числа с плавающей точкой. В качестве дополнительного аргумента указывается количество отображаемых точек после запятой, по умолчанию их две. Символ разделителя, по умолчанию, точка (.), но вы можете указать другой символ в свойстве **decimalSeparator** класса **Formatter**.

* **decimal** 
  * Возвращает строковое представление данного значения в виде действительного числа с плавающей точкой. В качестве дополнительного аргумента указывается количество отображаемых цифр после запятой, по умолчанию их два. Символ разделителя целой и дробной частей берётся из свойства **decimalSeparator** класса **Formatter**, а символ разделителя тысяч берётся из свойства **thousandSeparator**. По умолчанию они зависят от текущих настроек локали.

* **percent** 
  * переданное значение должно быть числовым, так как оно будет умножено на 100 и к нему будет приписан символ « **%** ». Таким образом, значение 0.75 будет превращено в строку « **75%** ». Дополнительный аргумент настраивает количество цифр после запятой в полученном количестве процентов, которое нужно отображать (по умолчанию равно нулю).

* **scientiffic** 
  * форматирует переданное число в научном формате, например число 100000 будет отображено как **1.00000E+5**. Можете посмотреть документацию к ключу **E** для функции sprintf здесь: [http://php.net/manual/ru/function.sprintf.php](http://php.net/manual/ru/function.sprintf.php), чтобы узнать подробности представления чисел в научном формате в PHP. Так же, как и формат **decimal**, примнмает в качестве дополнительного аргумента количество цифр после запятой, которое нужно отображать.

* **currency** 
  * формирует переданное число в виде суммы денег. В качестве дополнительного аргумента передаётся трёхбуквенный код валюты, согласно стандарту ISO 4217. Если его нет, то будет использовано значение свойства **currencyCode** класса **Formatter**, которое устанавливается в зависимости от расширения **PHP intl**. Если оно установлено, то форматирование переданного значения будет производится методом **NumberFormatter::formatCurrency()**  (см. [http://php.net/manual/en/numberformatter.formatcurrency.php](http://php.net/manual/en/numberformatter.formatcurrency.php)). Если нет, то тогда код валюты будет преобразован форматом **decimal** с двумя цифрами после запятой.

* **spellout** 
  * превращает переданное число в его текстовое представление, как оно произносится, используя из PHP класс **NumberFormatter** в «стиле» **NuvberFormatter::SPELLOUT**. Если не установлено расширение **PHP intl**, бросает исключение **InvalidConfigException**.

* **ordinal** 
  * превращает переданное число в порядковое числительное, используя из PHP класс  **NumberFormatter** в «стиле» **NuvberFormatter::SPELLOUT**. Если не установлено расширение **PHP intl**, бросает исключение **InvalidConfigException**.

* **shortsize** 
  * расценивает переданное значение как количество байт и очень старается описать это число в больших размерах, например кило- или мегабайтах. Дополнительный аргумент задает количество цифр после запятой. Свойство **sizeFormatBase** класса **Formatter** условно определяет число байт в килобайте. Если значением этого свойства является число 1024 (чем оно является по умолчанию), то данный формат будет использовать двоичные единицы измерения (KiB, MiB и т. д.), в противном случае будут использованы обычные десятичные префиксы (KB, MB и т. д.).

* **size** 
  * то же самое, что и **shortsize**, но вместо сокращенных обозначений единиц измерения будут использованы полные локализованные названия этих единиц измерения. (кибибайты, мебибайты, килобайты, магабайты, и т. д.).




